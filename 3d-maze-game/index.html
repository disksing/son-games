<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D迷宫大挑战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 18px;
        }

        #preparation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            font-size: 48px;
            font-weight: bold;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
        }

        .button {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="ui">
            <div>时间: <span id="time">10</span>秒</div>
            <div style="margin-top: 10px;">状态: <span id="status">准备中</span></div>
        </div>
        <div id="preparation">
            <div>准备时间</div>
            <div style="font-size: 72px; margin-top: 20px;" id="countdown">10</div>
            <div style="font-size: 24px; margin-top: 20px;">熟悉路线，找到观景台！</div>
        </div>
        <div id="instructions">
            方向键 ↑↓←→ 移动 | WASD 调整视角 (W前上/S后退/AD左右转)
        </div>
        <button class="button" onclick="resetGame()">重新开始</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, player;
        let walls = [];
        let keys = {};
        let gameState = {
            preparationTime: 10,
            gameStarted: false,
            onPlatform: false,
            cameraMode: 'thirdPerson', // 'thirdPerson' or 'platform'
            cameraAngle: 0, // 相机左右旋转角度
            cameraDistance: 4, // 相机距离
            cameraHeight: 2 // 相机高度
        };

        // 迷宫配置
        const MAZE_SIZE = 15;
        const WALL_HEIGHT = 3;
        const CELL_SIZE = 3;
        const maze = [];

        // 初始化场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1.5, 1.5, 1.5);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // 生成迷宫
            generateMaze();
            createMaze();
            createPlatform();
            createPlayer();
            createGround();

            // 键盘事件
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 窗口调整
            window.addEventListener('resize', onWindowResize);

            // 开始准备倒计时
            startPreparation();
        }

        // 生成迷宫算法（递归回溯）
        function generateMaze() {
            // 初始化迷宫（1表示墙，0表示路）
            for (let i = 0; i < MAZE_SIZE; i++) {
                maze[i] = [];
                for (let j = 0; j < MAZE_SIZE; j++) {
                    maze[i][j] = 1; // 全部初始化为墙
                }
            }

            // 使用递归回溯算法生成迷宫
            function carve(x, y) {
                maze[x][y] = 0; // 标记为路

                const directions = [
                    [0, 2], [2, 0], [0, -2], [-2, 0]
                ];

                // 随机打乱方向
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }

                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx > 0 && nx < MAZE_SIZE - 1 && ny > 0 && ny < MAZE_SIZE - 1 && maze[nx][ny] === 1) {
                        maze[x + dx / 2][y + dy / 2] = 0; // 打通中间的墙
                        carve(nx, ny);
                    }
                }
            }

            // 从(1,1)开始生成
            carve(1, 1);

            // 确保入口和出口
            maze[1][0] = 0; // 入口
            maze[MAZE_SIZE - 2][MAZE_SIZE - 1] = 0; // 出口
        }

        // 创建迷宫3D模型
        function createMaze() {
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });

            for (let i = 0; i < MAZE_SIZE; i++) {
                for (let j = 0; j < MAZE_SIZE; j++) {
                    if (maze[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(
                            (i - MAZE_SIZE / 2) * CELL_SIZE,
                            WALL_HEIGHT / 2,
                            (j - MAZE_SIZE / 2) * CELL_SIZE
                        );
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
        }

        // 创建观景台
        function createPlatform() {
            const platformSize = MAZE_SIZE * CELL_SIZE * 0.6;
            const platformGeometry = new THREE.CylinderGeometry(platformSize / 2, platformSize / 2, 0.5, 32);
            const platformMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });

            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(0, WALL_HEIGHT + 1, 0);
            platform.receiveShadow = true;
            scene.add(platform);

            // 添加围栏
            const railingGeometry = new THREE.CylinderGeometry(platformSize / 2 + 0.5, platformSize / 2 + 0.5, 1, 32);
            const railingMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const railing = new THREE.Mesh(railingGeometry, railingMaterial);
            railing.position.set(0, WALL_HEIGHT + 1.75, 0);
            scene.add(railing);
        }

        // 创建玩家
        function createPlayer() {
            // 使用组合几何体创建玩家（更明显）
            const playerGroup = new THREE.Group();

            // 身体（更大更明显）
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 12);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            playerGroup.add(body);

            // 头部（更大更明显）
            const headGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            playerGroup.add(head);

            // 添加眼睛
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 1.55, 0.25);
            playerGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 1.55, 0.25);
            playerGroup.add(rightEye);

            player = playerGroup;
            player.position.set(
                (1 - MAZE_SIZE / 2) * CELL_SIZE,
                0,
                (0 - MAZE_SIZE / 2) * CELL_SIZE
            );
            scene.add(player);
        }

        // 创建地面
        function createGround() {
            const groundSize = MAZE_SIZE * CELL_SIZE + 10;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // 键盘按下
        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;

            // 切换到观景台视角
            if (event.key === ' ' || event.key === 'Space') {
                if (gameState.onPlatform) {
                    toggleCameraMode();
                }
            }
        }

        // 键盘释放
        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        // 切换相机模式
        function toggleCameraMode() {
            if (gameState.cameraMode === 'thirdPerson') {
                // 切换到观景台视角
                gameState.cameraMode = 'platform';
                camera.position.set(0, WALL_HEIGHT + 4, 0);
                camera.lookAt(0, 0, 0);
            } else {
                // 切换回第三人称
                gameState.cameraMode = 'thirdPerson';
                updateCamera();
            }
        }

        // 控制相机视角
        function controlCamera() {
            if (!gameState.gameStarted || gameState.cameraMode === 'platform') return;

            const rotateSpeed = 0.03;
            const distanceSpeed = 0.1;
            const heightSpeed = 0.05;

            // W: 视角向前上（拉近并稍微提高）
            if (keys['w']) {
                gameState.cameraDistance = Math.max(2, gameState.cameraDistance - distanceSpeed);
                gameState.cameraHeight = Math.min(3, gameState.cameraHeight + heightSpeed * 0.5);
            }
            // S: 视角后退（拉远）
            if (keys['s']) {
                gameState.cameraDistance = Math.min(6, gameState.cameraDistance + distanceSpeed);
                gameState.cameraHeight = Math.max(1.5, gameState.cameraHeight - heightSpeed * 0.5);
            }
            // A: 视角左转
            if (keys['a']) {
                gameState.cameraAngle += rotateSpeed;
            }
            // D: 视角右转
            if (keys['d']) {
                gameState.cameraAngle -= rotateSpeed;
            }

            updateCamera();
        }

        // 移动玩家（只用方向键）
        function movePlayer() {
            if (!gameState.gameStarted || gameState.cameraMode === 'platform') return;

            const moveSpeed = 0.08;
            let moveX = 0;
            let moveZ = 0;

            // 只使用方向键控制移动方向（相对于世界坐标）
            if (keys['arrowup']) {
                moveZ -= moveSpeed;
            }
            if (keys['arrowdown']) {
                moveZ += moveSpeed;
            }
            if (keys['arrowleft']) {
                moveX -= moveSpeed;
            }
            if (keys['arrowright']) {
                moveX += moveSpeed;
            }

            if (moveX !== 0 || moveZ !== 0) {
                // 分别检查X和Z方向的碰撞，允许滑动
                let newX = player.position.x;
                let newZ = player.position.z;

                // 先检查X方向
                if (moveX !== 0 && !checkCollision(player.position.x + moveX, player.position.z)) {
                    newX = player.position.x + moveX;
                }

                // 再检查Z方向
                if (moveZ !== 0 && !checkCollision(newX, player.position.z + moveZ)) {
                    newZ = player.position.z + moveZ;
                }

                // 更新位置
                player.position.x = newX;
                player.position.z = newZ;

                // 更新玩家朝向
                if (moveX !== 0 || moveZ !== 0) {
                    const angle = Math.atan2(moveX, moveZ);
                    player.rotation.y = angle;
                }

                updateCamera();

                // 检查是否到达观景台
                checkPlatform();
            }
        }

        // 检查碰撞（改进版，检查玩家周围的多个点）
        function checkCollision(x, z) {
            const playerRadius = 0.4;
            const checkPoints = [
                { x: x, z: z }, // 中心
                { x: x + playerRadius, z: z }, // 右
                { x: x - playerRadius, z: z }, // 左
                { x: x, z: z + playerRadius }, // 前
                { x: x, z: z - playerRadius }, // 后
                { x: x + playerRadius * 0.7, z: z + playerRadius * 0.7 }, // 右前
                { x: x - playerRadius * 0.7, z: z + playerRadius * 0.7 }, // 左前
                { x: x + playerRadius * 0.7, z: z - playerRadius * 0.7 }, // 右后
                { x: x - playerRadius * 0.7, z: z - playerRadius * 0.7 }  // 左后
            ];

            for (const point of checkPoints) {
                const gridX = Math.floor((point.x + MAZE_SIZE * CELL_SIZE / 2) / CELL_SIZE);
                const gridZ = Math.floor((point.z + MAZE_SIZE * CELL_SIZE / 2) / CELL_SIZE);

                // 检查边界
                if (gridX < 0 || gridX >= MAZE_SIZE || gridZ < 0 || gridZ >= MAZE_SIZE) {
                    return true; // 超出边界
                }

                // 检查是否撞墙
                if (maze[gridX][gridZ] === 1) {
                    return true; // 撞墙
                }
            }

            return false; // 没有碰撞
        }

        // 检查是否到达观景台
        function checkPlatform() {
            const distance = Math.sqrt(
                Math.pow(player.position.x, 2) +
                Math.pow(player.position.z, 2)
            );

            if (distance < 2 && !gameState.onPlatform) {
                gameState.onPlatform = true;
                document.getElementById('status').textContent = '在观景台';
                document.getElementById('instructions').textContent = '按空格键切换视角查看迷宫全貌';
            } else if (distance >= 2 && gameState.onPlatform) {
                gameState.onPlatform = false;
                gameState.cameraMode = 'thirdPerson';
                document.getElementById('status').textContent = '游戏中';
                document.getElementById('instructions').textContent = '方向键 ↑↓←→ 移动 | WASD 调整视角 (W前上/S后退/AD左右转)';
            }
        }

        // 更新相机位置（第三人称）
        function updateCamera() {
            if (gameState.cameraMode === 'thirdPerson') {
                // 第三人称视角：相机围绕玩家旋转
                // 结合玩家朝向和相机角度
                const totalAngle = player.rotation.y + gameState.cameraAngle;

                // 计算相机位置（在玩家后方，根据角度旋转）
                const cameraX = player.position.x - Math.sin(totalAngle) * gameState.cameraDistance;
                const cameraZ = player.position.z - Math.cos(totalAngle) * gameState.cameraDistance;

                camera.position.set(
                    cameraX,
                    player.position.y + gameState.cameraHeight,
                    cameraZ
                );

                // 相机看向玩家
                camera.lookAt(
                    player.position.x,
                    player.position.y + 1,
                    player.position.z
                );
            }
        }

        // 开始准备倒计时
        function startPreparation() {
            let timeLeft = gameState.preparationTime;
            const countdownEl = document.getElementById('countdown');
            const preparationEl = document.getElementById('preparation');

            // 切换到观景台视角
            gameState.cameraMode = 'platform';
            camera.position.set(0, WALL_HEIGHT + 6, MAZE_SIZE * CELL_SIZE);
            camera.lookAt(0, 0, 0);

            const timer = setInterval(() => {
                timeLeft--;
                countdownEl.textContent = timeLeft;
                document.getElementById('time').textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(timer);
                    preparationEl.style.display = 'none';
                    gameState.gameStarted = true;
                    gameState.cameraMode = 'thirdPerson';
                    gameState.cameraAngle = 0;
                    gameState.cameraDistance = 4;
                    gameState.cameraHeight = 2;
                    updateCamera();
                    document.getElementById('status').textContent = '游戏中';
                    document.getElementById('instructions').textContent = '方向键 ↑↓←→ 移动 | WASD 调整视角 (W前上/S后退/AD左右转)';
                }
            }, 1000);
        }

        // 重置游戏
        function resetGame() {
            location.reload();
        }

        // 窗口调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controlCamera();
            movePlayer();
            if (gameState.gameStarted && gameState.cameraMode === 'thirdPerson') {
                updateCamera();
            }
            renderer.render(scene, camera);
        }

        // 启动
        init();
        animate();
    </script>
</body>

</html>