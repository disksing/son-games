<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <title>éšœç¢è·‘é…·</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #1a1a2e;
            color: #e6f0ff;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, PingFang SC, Noto Sans SC, "Microsoft Yahei", sans-serif;
            overflow: hidden;
        }

        #game {
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 50%, #6B8E23 100%);
            box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
            touch-action: none;
        }

        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            pointer-events: none;
            z-index: 10;
        }

        .hud .pill {
            pointer-events: auto;
            background: rgba(0, 0, 0, .6);
            border: 1px solid rgba(255, 255, 255, .3);
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 14px;
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn {
            cursor: pointer;
            user-select: none;
        }

        .btn:hover {
            background: rgba(255, 255, 255, .1);
        }

        .center {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 20;
        }

        .panel {
            background: rgba(10, 14, 28, .95);
            border: 1px solid rgba(255, 255, 255, .2);
            border-radius: 16px;
            padding: 24px 28px;
            box-shadow: 0 10px 32px rgba(0, 0, 0, .6);
            text-align: center;
            max-width: 400px;
        }

        .title {
            font-weight: 700;
            font-size: 24px;
            margin-bottom: 12px;
            color: #ffd700;
        }

        .sub {
            opacity: .9;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .powerup-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .powerup-icon {
            font-size: 16px;
        }

        .fragment-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            margin: 12px 0;
            justify-items: center;
        }

        .reset-shard {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.15s ease, box-shadow 0.2s ease;
        }

        .reset-shard.active {
            background: linear-gradient(135deg, #a0e9ff, #7f7bf7);
            border-color: rgba(160, 233, 255, 0.8);
            box-shadow: 0 0 6px rgba(127, 123, 247, 0.6);
            transform: scale(1.1);
        }

        .pill.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        @keyframes pulse {
            from {
                opacity: 0.6;
            }

            to {
                opacity: 1;
            }
        }

        .shield-active {
            animation: pulse 0.8s infinite alternate;
            color: #00ff00 !important;
        }

        .speed-active {
            color: #ff6b6b !important;
        }
    </style>
</head>

<body>
    <canvas id="game" width="800" height="600"></canvas>
    <div class="hud">
        <div class="pill">ğŸ¯ å…³å¡: <span id="level">1</span>/20</div>
        <div class="pill">â¤ï¸ è¡€é‡: <span id="hp">100</span>/<span id="maxHp">100</span></div>
        <div class="pill">ğŸ’° é‡‘å¸: <span id="coins">0</span></div>
        <div class="pill">â± æ—¶é—´: <span id="time">0</span>s</div>
        <div class="pill" id="shieldIndicator" style="display: none;">
            <span class="powerup-icon">ğŸ›¡ï¸</span>
            <span>æŠ¤ç›¾</span>
        </div>
        <div class="pill" id="speedIndicator" style="display: none;">
            <span class="powerup-icon">âš¡</span>
            <span>åŠ é€Ÿ</span>
        </div>
        <div class="pill btn" id="pauseBtn">æš‚åœ â¸</div>
    </div>
    <div id="overlay" class="center"></div>

    <script>
        (function () {
            // è®¾å¤‡æ£€æµ‹
            function detectDevice() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const isMobile = isTouch && (width <= 768 || (width <= 1024 && height <= 768));
                const isTablet = isTouch && !isMobile && width <= 1024;
                return { isMobile, isTablet, isDesktop: !isMobile && !isTablet, isTouch };
            }

            const device = detectDevice();

            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            // æ ¹æ®è®¾å¤‡è°ƒæ•´åŸºç¡€å°ºå¯¸
            let baseW, baseH;
            if (device.isMobile) {
                baseW = Math.min(window.innerWidth, 480);
                baseH = Math.min(window.innerHeight, 800);
            } else if (device.isTablet) {
                baseW = Math.min(window.innerWidth * 0.9, 700);
                baseH = Math.min(window.innerHeight * 0.9, 600);
            } else {
                baseW = 800;
                baseH = 600;
            }

            // è®¾ç½®canvaså°ºå¯¸
            canvas.width = baseW;
            canvas.height = baseH;
            canvas.style.width = baseW + 'px';
            canvas.style.height = baseH + 'px';

            // Game state
            const state = {
                playing: false,
                paused: false,
                gameTime: 0,
                coinCounter: 0, // ç”¨äºç´¯è®¡æ—¶é—´é‡‘å¸ï¼ˆ0.1/ç§’ï¼‰
                coins: 0, // æ˜¾ç¤ºçš„é‡‘å¸æ•°ï¼ˆæ•´æ•°ï¼‰
                hp: 100, // è¡€é‡
                maxHp: 100, // æœ€å¤§è¡€é‡ï¼ˆä¼šåœ¨åˆå§‹åŒ–åæ›´æ–°ï¼‰
                damagePerHit: 10, // æ¯æ¬¡æ’éšœç¢æ‰£è¡€é‡ï¼ˆä¼šåœ¨åˆå§‹åŒ–åæ›´æ–°ï¼‰
                lastCoinDropTime: 0, // ä¸Šæ¬¡æ‰è½é‡‘å¸çš„æ—¶é—´
                coinSpawnInterval: 10, // é‡‘å¸ç”Ÿæˆé—´éš”ï¼ˆç§’ï¼‰
                distance: 0,
                speed: 3,
                baseSpeed: 3,
                baseMaxV: 6, // åŸºç¡€æœ€å¤§é€Ÿåº¦
                tick: 0,
                trackWidth: device.isMobile ? Math.min(300, baseW * 0.8) : device.isTablet ? Math.min(500, baseW * 0.85) : 400, // èµ›é“å®½åº¦ï¼ˆæ‰‹æœºç¼©å°ï¼Œå¹³æ¿ç¨å®½ï¼‰
                trackX: baseW * 0.5, // èµ›é“ä¸­å¿ƒX
                player: {
                    x: baseW * 0.5,
                    y: baseH - 80,
                    w: 40,
                    h: 50,
                    vx: 0,
                    vy: 0, // å‰åç§»åŠ¨é€Ÿåº¦
                    maxV: 6,
                    maxVy: 4, // å‰åç§»åŠ¨æœ€å¤§é€Ÿåº¦
                    runFrame: 0, // å¥”è·‘åŠ¨ç”»å¸§
                    lastStepTime: 0 // ä¸Šæ¬¡è¸æ­¥æ—¶é—´
                },
                obstacles: [],
                coinObjects: [],
                powerups: [],
                enemies: [], // æ•Œäºº
                bullets: [], // å­å¼¹
                thunderStrikes: [], // é›·å‡»ï¼ˆä»å¤©è€Œé™ï¼‰
                hasShield: false,
                shieldTime: 0,
                speedBoost: false,
                speedBoostTime: 0,
                activePowerup: null, // å½“å‰æ¿€æ´»çš„é“å…·ï¼ˆç¬¬äºŒä¸ªä¼šå–æ¶ˆç¬¬ä¸€ä¸ªï¼‰
                gameOver: false,
                currentLevel: parseInt(localStorage.getItem('obstacleRunnerCurrentLevel') || '1'), // å½“å‰å…³å¡
                maxLevel: 20, // æœ€å¤§å…³å¡
                levelTime: 0, // å½“å‰å…³å¡æ—¶é—´
                levelTargetTime: 30, // æ¯å…³ç›®æ ‡æ—¶é—´ï¼ˆç§’ï¼‰
                highScore: parseInt(localStorage.getItem('obstacleRunnerHighScore') || '0'),
                totalCoins: parseInt(localStorage.getItem('obstacleRunnerTotalCoins') || '0'),
                maxHpUpgrade: parseInt(localStorage.getItem('obstacleRunnerMaxHpUpgrade') || '0'), // è¡€é‡ä¸Šé™å‡çº§æ¬¡æ•°
                damageReduction: parseInt(localStorage.getItem('obstacleRunnerDamageReduction') || '0'), // ä¼¤å®³å‡å°‘æ¬¡æ•°
                coinSpawnSpeedUpgrade: parseInt(localStorage.getItem('obstacleRunnerCoinSpawnSpeedUpgrade') || '0'), // é‡‘å¸ç”Ÿæˆé€Ÿåº¦å‡çº§æ¬¡æ•°
                playerSpeedUpgrade: parseInt(localStorage.getItem('obstacleRunnerPlayerSpeedUpgrade') || '0'), // ç©å®¶é€Ÿåº¦å‡çº§æ¬¡æ•°
                shopPrices: JSON.parse(localStorage.getItem('obstacleRunnerShopPrices') || '{}') // å•†åº—ä»·æ ¼ï¼ˆæ¯æ¬¡è´­ä¹°åå¢åŠ 15%ï¼‰
            };

            // åˆå§‹åŒ–å‡çº§åçš„å€¼
            state.maxHp = 100 + state.maxHpUpgrade * 20; // æ¯æ¬¡å‡çº§+20è¡€
            state.damagePerHit = Math.max(1, 10 - state.damageReduction); // åŸºç¡€ä¼¤å®³10

            // åˆå§‹åŒ–é‡‘å¸ç”Ÿæˆé€Ÿåº¦
            if (state.coinSpawnSpeedUpgrade === 0) {
                state.coinSpawnInterval = 10;
            } else if (state.coinSpawnSpeedUpgrade === 1) {
                state.coinSpawnInterval = 5;
            } else if (state.coinSpawnSpeedUpgrade === 2) {
                state.coinSpawnInterval = 3;
            } else {
                state.coinSpawnInterval = 1;
            }

            // åˆå§‹åŒ–ç©å®¶é€Ÿåº¦
            state.baseMaxV = 6 + state.playerSpeedUpgrade * 1;
            state.player.maxV = state.baseMaxV;

            // Helpers
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            function aabb(a, b) {
                return Math.abs(a.x - b.x) < (a.w + b.w) / 2 && Math.abs(a.y - b.y) < (a.h + b.h) / 2;
            }

            // éŸ³æ•ˆç”Ÿæˆ
            let audioContext = null;
            function initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    // å¿½ç•¥éŸ³æ•ˆåˆå§‹åŒ–é”™è¯¯
                }
            }

            function playStepSound() {
                if (!audioContext) {
                    initAudio();
                    if (!audioContext) return;
                }

                try {
                    // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¢«æš‚åœï¼‰
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 200 + Math.random() * 50;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.08);
                } catch (e) {
                    // å¿½ç•¥éŸ³æ•ˆé”™è¯¯
                }
            }

            function playExplosionSound() {
                if (!audioContext) {
                    initAudio();
                    if (!audioContext) return;
                }
                try {
                    // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¢«æš‚åœï¼‰
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }

                    // åˆ›å»ºçˆ†ç‚¸éŸ³æ•ˆï¼ˆä½æ²‰çš„è½°éš†å£°ï¼‰
                    const oscillator1 = audioContext.createOscillator();
                    const oscillator2 = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // ä½é¢‘è½°éš†å£°
                    oscillator1.frequency.value = 60;
                    oscillator1.type = 'sawtooth';
                    oscillator2.frequency.value = 80;
                    oscillator2.type = 'square';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                    oscillator1.start(audioContext.currentTime);
                    oscillator2.start(audioContext.currentTime);
                    oscillator1.stop(audioContext.currentTime + 0.5);
                    oscillator2.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    // å¿½ç•¥éŸ³æ•ˆé”™è¯¯
                }
            }

            // åˆå§‹åŒ–éŸ³æ•ˆï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åï¼‰
            initAudio();

            // Overlay rendering
            const overlay = document.getElementById('overlay');
            function showStart() {
                overlay.innerHTML = `
        <div class="panel">
          <div class="title">ğŸƒ éšœç¢è·‘é…·</div>
          <div class="sub">ä½¿ç”¨æ–¹å‘é”® â† â†’ æ§åˆ¶è§’è‰²å·¦å³ç§»åŠ¨<br>
          èº²é¿éšœç¢ç‰©ï¼Œæ”¶é›†é‡‘å¸å’Œé“å…·ï¼<br>
          â¤ï¸ æ’åˆ°éšœç¢ç‰©æ‰£${state.damagePerHit}æ»´è¡€ï¼Œè¢«ç‚¸å¼¹ç ¸ä¸­æ‰£20æ»´è¡€ï¼Œ${state.maxHp}æ»´è¡€æ‰£å®Œæ¸¸æˆç»“æŸ<br>
          ğŸ›¡ï¸ æŠ¤ç›¾ï¼šå¯æŠµæŒ¡ä¸€æ¬¡éšœç¢<br>
          âš¡ åŠ é€Ÿï¼šç§»åŠ¨é€Ÿåº¦æå‡<br>
          ğŸ’° æ¯åšæŒ10ç§’ä¼šæ‰è½ä¸€ä¸ªé‡‘å¸ï¼Œè®°å¾—å»æ¡ï¼<br>
          ğŸ›’ åœ¨å•†åº—å¯ä»¥å‡çº§è¡€é‡å’Œå‡å°‘æ‰£è¡€é‡</div>
          <div class="sub" style="margin-top: 12px; color: #ffd700;">
            å½“å‰å…³å¡: ç¬¬ ${state.currentLevel} å…³ / 20å…³<br>
            æœ€é«˜è®°å½•: ${Math.floor(state.highScore)}s | æ€»é‡‘å¸: ${state.totalCoins}
          </div>
          <div class="controls">
            <div class="pill btn" id="startBtn">å¼€å§‹æ¸¸æˆ â–¶</div>
            <div class="pill btn" id="shopBtn" style="background: rgba(255,215,0,.2); border-color: rgba(255,215,0,.5);">å•†åº— ğŸ›’</div>
          </div>
        </div>`;
                bindStart();
            }

            function showGameOver() {
                overlay.innerHTML = `
        <div class="panel">
          <div class="title">æ¸¸æˆç»“æŸ ğŸ’¥</div>
          <div class="sub">å­˜æ´»æ—¶é—´: ${Math.floor(state.gameTime)}ç§’</div>
          <div class="sub">è·å¾—é‡‘å¸: ${state.coins}</div>
          <div class="sub">æ€»é‡‘å¸: ${state.totalCoins}</div>
          ${state.gameTime > state.highScore ? '<div class="sub" style="color: #ffd700; margin-top: 8px;">ğŸ† æ–°è®°å½•ï¼</div>' : ''}
          <div class="controls">
            <div class="pill btn" id="restartBtn">å†æ¥ä¸€æ¬¡ â†»</div>
            <div class="pill btn" id="shopBtn2" style="background: rgba(255,215,0,.2); border-color: rgba(255,215,0,.5);">å•†åº— ğŸ›’</div>
          </div>
        </div>`;
                bindRestart();
            }

            function clearOverlay() { overlay.innerHTML = ''; }

            function bindStart() {
                const btn = document.getElementById('startBtn');
                if (btn) btn.onclick = startGame;
                const shopBtn = document.getElementById('shopBtn');
                if (shopBtn) shopBtn.onclick = showShop;
            }

            function bindRestart() {
                const btn = document.getElementById('restartBtn');
                if (btn) btn.onclick = startGame;
                const shopBtn = document.getElementById('shopBtn2');
                if (shopBtn) shopBtn.onclick = showShop;
            }

            // è·å–å•†åº—ä»·æ ¼ï¼ˆæ¯æ¬¡è´­ä¹°åå¢åŠ 15%ï¼‰
            function getShopPrice(itemName, basePrice, purchaseCount) {
                // è®¡ç®—ä»·æ ¼ï¼šåŸºç¡€ä»·æ ¼ * (1.15 ^ è´­ä¹°æ¬¡æ•°)
                const price = Math.floor(basePrice * Math.pow(1.15, purchaseCount));
                return price;
            }

            function showShop() {
                // ç¡®ä¿æ¸¸æˆæš‚åœ
                if (state.playing) {
                    state.paused = true;
                }

                const maxHpPrice = getShopPrice('maxHp', 50, state.maxHpUpgrade);
                const damageReductionPrice = getShopPrice('damageReduction', 30, state.damageReduction);
                const coinSpawnSpeedPrice = getShopPrice('coinSpawnSpeed', 40, state.coinSpawnSpeedUpgrade);
                const playerSpeedPrice = getShopPrice('playerSpeed', 35, state.playerSpeedUpgrade);

                const currentDamage = Math.max(1, 10 - state.damageReduction);
                const nextCoinInterval = state.coinSpawnSpeedUpgrade === 0 ? 5 :
                    state.coinSpawnSpeedUpgrade === 1 ? 3 :
                        state.coinSpawnSpeedUpgrade === 2 ? 1 : 1;
                const coinSpawnMaxed = state.coinSpawnSpeedUpgrade >= 3;

                overlay.innerHTML = `
        <div class="panel" style="max-width: 500px;">
          <div class="title">å•†åº— ğŸ›’</div>
          <div class="sub" style="margin-bottom: 16px;">å½“å‰é‡‘å¸: ${state.totalCoins}</div>
          
          <div style="text-align: left; margin: 12px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,.05); border-radius: 8px;">
              <div>
                <div style="font-weight: bold;">â¤ï¸ å¢åŠ è¡€é‡ä¸Šé™ <span style="color: #ffd700;">(å·²è´­ä¹°: ${state.maxHpUpgrade})</span></div>
                <div style="font-size: 12px; opacity: 0.8;">å½“å‰: ${state.maxHp} | å‡çº§å: ${state.maxHp + 20}</div>
              </div>
              <div class="pill btn" id="buyMaxHp" style="background: ${state.totalCoins >= maxHpPrice ? 'rgba(0,255,0,.2)' : 'rgba(255,0,0,.2)'}; border-color: ${state.totalCoins >= maxHpPrice ? 'rgba(0,255,0,.5)' : 'rgba(255,0,0,.5)'};">
                ${state.totalCoins >= maxHpPrice ? `è´­ä¹° (${maxHpPrice})` : `é‡‘å¸ä¸è¶³ (${maxHpPrice})`}
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,.05); border-radius: 8px;">
              <div>
                <div style="font-weight: bold;">ğŸ›¡ï¸ å‡å°‘æ‰£è¡€é‡ <span style="color: #ffd700;">(å·²è´­ä¹°: ${state.damageReduction})</span></div>
                <div style="font-size: 12px; opacity: 0.8;">å½“å‰: ${currentDamage} | å‡çº§å: ${Math.max(1, currentDamage - 1)}</div>
              </div>
              <div class="pill btn" id="buyDamageReduction" style="background: ${state.totalCoins >= damageReductionPrice && currentDamage > 1 ? 'rgba(0,255,0,.2)' : 'rgba(255,0,0,.2)'}; border-color: ${state.totalCoins >= damageReductionPrice && currentDamage > 1 ? 'rgba(0,255,0,.5)' : 'rgba(255,0,0,.5)'};">
                ${currentDamage <= 1 ? 'å·²æ»¡çº§' : state.totalCoins >= damageReductionPrice ? `è´­ä¹° (${damageReductionPrice})` : `é‡‘å¸ä¸è¶³ (${damageReductionPrice})`}
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,.05); border-radius: 8px;">
              <div>
                <div style="font-weight: bold;">âš¡ é‡‘å¸ç”Ÿæˆé€Ÿåº¦ <span style="color: #ffd700;">(å·²è´­ä¹°: ${state.coinSpawnSpeedUpgrade})</span></div>
                <div style="font-size: 12px; opacity: 0.8;">å½“å‰: ${state.coinSpawnInterval}ç§’ | ${coinSpawnMaxed ? 'å·²æ»¡çº§' : `å‡çº§å: ${nextCoinInterval}ç§’`}</div>
              </div>
              <div class="pill btn" id="buyCoinSpawnSpeed" style="background: ${!coinSpawnMaxed && state.totalCoins >= coinSpawnSpeedPrice ? 'rgba(0,255,0,.2)' : 'rgba(255,0,0,.2)'}; border-color: ${!coinSpawnMaxed && state.totalCoins >= coinSpawnSpeedPrice ? 'rgba(0,255,0,.5)' : 'rgba(255,0,0,.5)'};">
                ${coinSpawnMaxed ? 'å·²æ»¡çº§' : state.totalCoins >= coinSpawnSpeedPrice ? `è´­ä¹° (${coinSpawnSpeedPrice})` : `é‡‘å¸ä¸è¶³ (${coinSpawnSpeedPrice})`}
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,.05); border-radius: 8px;">
              <div>
                <div style="font-weight: bold;">ğŸƒ ç©å®¶é€Ÿåº¦ <span style="color: #ffd700;">(å·²è´­ä¹°: ${state.playerSpeedUpgrade})</span></div>
                <div style="font-size: 12px; opacity: 0.8;">å½“å‰: ${state.baseMaxV} | å‡çº§å: ${state.baseMaxV + 1}</div>
              </div>
              <div class="pill btn" id="buyPlayerSpeed" style="background: ${state.totalCoins >= playerSpeedPrice ? 'rgba(0,255,0,.2)' : 'rgba(255,0,0,.2)'}; border-color: ${state.totalCoins >= playerSpeedPrice ? 'rgba(0,255,0,.5)' : 'rgba(255,0,0,.5)'};">
                ${state.totalCoins >= playerSpeedPrice ? `è´­ä¹° (${playerSpeedPrice})` : `é‡‘å¸ä¸è¶³ (${playerSpeedPrice})`}
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 8px; background: rgba(255,255,255,.05); border-radius: 8px;">
              <div>
                <div style="font-weight: bold;">ğŸ’° å½“å‰çŠ¶æ€</div>
                <div style="font-size: 12px; opacity: 0.8;">è¡€é‡ä¸Šé™: ${state.maxHp} | æ¯æ¬¡æ‰£è¡€: ${currentDamage} | é‡‘å¸é—´éš”: ${state.coinSpawnInterval}ç§’ | é€Ÿåº¦: ${state.baseMaxV}</div>
              </div>
            </div>
          </div>
          
          <div class="controls">
            <div class="pill btn" id="backBtn">è¿”å› â†©</div>
          </div>
        </div>`;

                const buyMaxHpBtn = document.getElementById('buyMaxHp');
                const buyDamageReductionBtn = document.getElementById('buyDamageReduction');
                const buyCoinSpawnSpeedBtn = document.getElementById('buyCoinSpawnSpeed');
                const buyPlayerSpeedBtn = document.getElementById('buyPlayerSpeed');
                const backBtn = document.getElementById('backBtn');

                if (buyMaxHpBtn) {
                    buyMaxHpBtn.onclick = () => {
                        if (state.totalCoins >= maxHpPrice) {
                            state.totalCoins -= maxHpPrice;
                            state.maxHpUpgrade++;
                            state.maxHp = 100 + state.maxHpUpgrade * 20;
                            localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);
                            localStorage.setItem('obstacleRunnerMaxHpUpgrade', state.maxHpUpgrade);
                            showShop();
                        }
                    };
                }

                if (buyDamageReductionBtn) {
                    buyDamageReductionBtn.onclick = () => {
                        if (state.totalCoins >= damageReductionPrice && currentDamage > 1) {
                            state.totalCoins -= damageReductionPrice;
                            state.damageReduction++;
                            state.damagePerHit = Math.max(1, 10 - state.damageReduction);
                            localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);
                            localStorage.setItem('obstacleRunnerDamageReduction', state.damageReduction);
                            showShop();
                        }
                    };
                }

                if (buyCoinSpawnSpeedBtn) {
                    buyCoinSpawnSpeedBtn.onclick = () => {
                        if (!coinSpawnMaxed && state.totalCoins >= coinSpawnSpeedPrice) {
                            state.totalCoins -= coinSpawnSpeedPrice;
                            state.coinSpawnSpeedUpgrade++;
                            if (state.coinSpawnSpeedUpgrade === 1) {
                                state.coinSpawnInterval = 5;
                            } else if (state.coinSpawnSpeedUpgrade === 2) {
                                state.coinSpawnInterval = 3;
                            } else if (state.coinSpawnSpeedUpgrade >= 3) {
                                state.coinSpawnInterval = 1;
                            }
                            localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);
                            localStorage.setItem('obstacleRunnerCoinSpawnSpeedUpgrade', state.coinSpawnSpeedUpgrade);
                            showShop();
                        }
                    };
                }

                if (buyPlayerSpeedBtn) {
                    buyPlayerSpeedBtn.onclick = () => {
                        if (state.totalCoins >= playerSpeedPrice) {
                            state.totalCoins -= playerSpeedPrice;
                            state.playerSpeedUpgrade++;
                            state.baseMaxV = 6 + state.playerSpeedUpgrade * 1;
                            state.player.maxV = state.baseMaxV;
                            localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);
                            localStorage.setItem('obstacleRunnerPlayerSpeedUpgrade', state.playerSpeedUpgrade);
                            showShop();
                        }
                    };
                }

                if (backBtn) {
                    backBtn.onclick = () => {
                        // æ¢å¤æ¸¸æˆçŠ¶æ€
                        if (state.playing) {
                            state.paused = false;
                        }
                        if (state.gameOver) {
                            showGameOver();
                        } else {
                            showStart();
                        }
                    };
                }
            }

            // Input
            const keys = { left: false, right: false, up: false, down: false };
            window.addEventListener('keydown', (e) => {
                // å¦‚æœoverlayæ˜¾ç¤ºï¼ˆå•†åº—ç­‰ï¼‰ï¼Œä¸å¤„ç†æ¸¸æˆè¾“å…¥
                if (overlay.innerHTML.trim() !== '') {
                    // é‡ç½®æŒ‰é”®çŠ¶æ€ï¼Œé¿å…å¡ä½
                    keys.left = false;
                    keys.right = false;
                    keys.up = false;
                    keys.down = false;
                    return;
                }
                if (e.key === 'ArrowLeft') keys.left = true;
                if (e.key === 'ArrowRight') keys.right = true;
                if (e.key === 'ArrowUp') keys.up = true;
                if (e.key === 'ArrowDown') keys.down = true;
                if (e.key.toLowerCase() === 'p') togglePause();
            });
            window.addEventListener('keyup', (e) => {
                // å¦‚æœoverlayæ˜¾ç¤ºï¼ˆå•†åº—ç­‰ï¼‰ï¼Œä¸å¤„ç†æ¸¸æˆè¾“å…¥
                if (overlay.innerHTML.trim() !== '') return;
                if (e.key === 'ArrowLeft') keys.left = false;
                if (e.key === 'ArrowRight') keys.right = false;
                if (e.key === 'ArrowUp') keys.up = false;
                if (e.key === 'ArrowDown') keys.down = false;
            });

            document.getElementById('pauseBtn').onclick = togglePause;

            // è§¦æ‘¸æ§åˆ¶ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            if (device.isTouch) {
                // æ·»åŠ è§¦æ‘¸æŒ‰é’®
                const touchControls = document.createElement('div');
                touchControls.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:100;';
                touchControls.innerHTML = `
                    <div style="display:grid;grid-template-columns:repeat(3,50px);grid-template-rows:repeat(3,50px);gap:5px;">
                        <button id="touchUp" style="grid-column:2;grid-row:1;width:50px;height:50px;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.4);border-radius:12px;color:#fff;font-size:24px;touch-action:manipulation;">â†‘</button>
                        <button id="touchLeft" style="grid-column:1;grid-row:2;width:50px;height:50px;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.4);border-radius:12px;color:#fff;font-size:24px;touch-action:manipulation;">â†</button>
                        <button id="touchDown" style="grid-column:2;grid-row:3;width:50px;height:50px;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.4);border-radius:12px;color:#fff;font-size:24px;touch-action:manipulation;">â†“</button>
                        <button id="touchRight" style="grid-column:3;grid-row:2;width:50px;height:50px;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.4);border-radius:12px;color:#fff;font-size:24px;touch-action:manipulation;">â†’</button>
                    </div>
                `;
                document.body.appendChild(touchControls);

                // ç»‘å®šè§¦æ‘¸æŒ‰é’®
                function bindTouchBtn(id, key) {
                    const btn = document.getElementById(id);
                    if (!btn) return;
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        keys[key] = true;
                    }, { passive: false });
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        keys[key] = false;
                    }, { passive: false });
                    btn.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        keys[key] = false;
                    }, { passive: false });
                }
                bindTouchBtn('touchUp', 'up');
                bindTouchBtn('touchDown', 'down');
                bindTouchBtn('touchLeft', 'left');
                bindTouchBtn('touchRight', 'right');
            }

            function togglePause() {
                if (!state.playing) return;
                state.paused = !state.paused;
                document.getElementById('pauseBtn').textContent = state.paused ? 'ç»§ç»­ â–¶' : 'æš‚åœ â¸';
            }

            // æ ¹æ®å…³å¡è°ƒæ•´éš¾åº¦
            function getLevelDifficulty(level) {
                // éšœç¢ç‰©ç”Ÿæˆé¢‘ç‡ï¼šç¬¬ä¸€å…³å°±å¾ˆå¤šï¼Œé€æ¸å¢åŠ åˆ°ç¬¬20å…³
                // ç¬¬ä¸€å…³ï¼š40ï¼Œç¬¬20å…³ï¼š15ï¼Œçº¿æ€§é€’å‡ï¼ˆæ›´é¢‘ç¹ï¼‰
                const baseObstacleSpawnRate = Math.max(15, 40 - (level - 1) * (25 / 19));
                // ç¬¬ä¸€å…³ï¼š0.5ï¼Œç¬¬20å…³ï¼š0.9ï¼Œçº¿æ€§é€’å¢ï¼ˆæ›´é«˜æ¦‚ç‡ï¼‰
                const obstacleSpawnChance = Math.min(0.9, 0.5 + (level - 1) * (0.4 / 19));
                const speedMultiplier = 1 + (level - 1) * 0.05; // æ¯å…³é€Ÿåº¦å¢åŠ 5%
                const obstacleSpeedMultiplier = 1 + (level - 1) * 0.03; // éšœç¢ç‰©é€Ÿåº¦æ¯å…³å¢åŠ 3%

                return {
                    obstacleSpawnRate: baseObstacleSpawnRate,
                    obstacleSpawnChance: obstacleSpawnChance,
                    speedMultiplier: speedMultiplier,
                    obstacleSpeedMultiplier: obstacleSpeedMultiplier
                };
            }

            // Game control
            function reset() {
                state.playing = true;
                state.paused = false;
                state.gameTime = 0;
                state.levelTime = 0;
                state.coinCounter = 0;
                state.coins = 0;
                // æ›´æ–°maxHpå’ŒdamagePerHitï¼ˆå¯èƒ½å·²å‡çº§ï¼‰
                state.maxHp = 100 + state.maxHpUpgrade * 20; // åŸºç¡€100è¡€ï¼Œæ¯æ¬¡å‡çº§+20
                state.damagePerHit = Math.max(1, 10 - state.damageReduction); // åŸºç¡€ä¼¤å®³10
                state.hp = state.maxHp;
                state.lastCoinDropTime = 0;
                state.distance = 0;

                // æ ¹æ®å…³å¡è°ƒæ•´é€Ÿåº¦
                const difficulty = getLevelDifficulty(state.currentLevel);
                state.baseSpeed = 3 * difficulty.speedMultiplier;
                state.speed = state.baseSpeed;

                state.tick = 0;
                state.gameOver = false;
                state.obstacles.length = 0;
                state.coinObjects.length = 0;
                state.powerups.length = 0;
                state.enemies.length = 0;
                state.bullets.length = 0;
                state.thunderStrikes.length = 0;
                state.player.x = baseW * 0.5;
                state.player.vx = 0;
                state.player.maxV = state.baseMaxV;
                state.hasShield = false;
                state.shieldTime = 0;
                state.speedBoost = false;
                state.speedBoostTime = 0;
                state.activePowerup = null;
                document.getElementById('pauseBtn').textContent = 'æš‚åœ â¸';
                document.getElementById('shieldIndicator').style.display = 'none';
                document.getElementById('speedIndicator').style.display = 'none';
            }

            function startGame() {
                reset();
                clearOverlay();
            }

            function completeLevel() {
                state.playing = false;
                state.totalCoins += state.coins;
                localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);

                const completedLevel = state.currentLevel;
                if (state.currentLevel < state.maxLevel) {
                    // è¿›å…¥ä¸‹ä¸€å…³
                    state.currentLevel++;
                    localStorage.setItem('obstacleRunnerCurrentLevel', state.currentLevel);
                    showLevelComplete(completedLevel);
                } else {
                    // é€šå…³
                    showGameComplete();
                }
            }

            function endGame() {
                state.playing = false;
                state.gameOver = true;
                if (state.gameTime > state.highScore) {
                    state.highScore = state.gameTime;
                    localStorage.setItem('obstacleRunnerHighScore', state.highScore);
                }
                state.totalCoins += state.coins;
                localStorage.setItem('obstacleRunnerTotalCoins', state.totalCoins);
                showGameOver();
            }

            function showLevelComplete(completedLevel) {
                overlay.innerHTML = `
        <div class="panel">
          <div class="title">ğŸ‰ å…³å¡å®Œæˆï¼</div>
          <div class="sub">ç¬¬ ${completedLevel} å…³å®Œæˆï¼</div>
          <div class="sub">è·å¾—é‡‘å¸: ${state.coins}</div>
          <div class="sub">æ€»é‡‘å¸: ${state.totalCoins}</div>
          <div class="sub" style="margin-top: 12px; color: #ffd700;">
            ${state.currentLevel <= state.maxLevel ? `ä¸‹ä¸€å…³: ç¬¬ ${state.currentLevel} å…³` : 'æ­å–œé€šå…³ï¼'}
          </div>
          <div class="controls">
            <div class="pill btn" id="nextLevelBtn">ä¸‹ä¸€å…³ â–¶</div>
            <div class="pill btn" id="backToMenuBtn">è¿”å›èœå• â†©</div>
          </div>
        </div>`;
                const nextLevelBtn = document.getElementById('nextLevelBtn');
                const backToMenuBtn = document.getElementById('backToMenuBtn');
                if (nextLevelBtn) nextLevelBtn.onclick = startGame;
                if (backToMenuBtn) backToMenuBtn.onclick = showStart;
            }

            function showGameComplete() {
                overlay.innerHTML = `
        <div class="panel">
          <div class="title">ğŸ† æ­å–œé€šå…³ï¼</div>
          <div class="sub">ä½ å®Œæˆäº†æ‰€æœ‰20å…³ï¼</div>
          <div class="sub">è·å¾—é‡‘å¸: ${state.coins}</div>
          <div class="sub">æ€»é‡‘å¸: ${state.totalCoins}</div>
          <div class="controls">
            <div class="pill btn" id="restartBtn">é‡æ–°å¼€å§‹ â†»</div>
            <div class="pill btn" id="backToMenuBtn">è¿”å›èœå• â†©</div>
          </div>
        </div>`;
                const restartBtn = document.getElementById('restartBtn');
                const backToMenuBtn = document.getElementById('backToMenuBtn');
                if (restartBtn) {
                    restartBtn.onclick = () => {
                        state.currentLevel = 1;
                        localStorage.setItem('obstacleRunnerCurrentLevel', 1);
                        startGame();
                    };
                }
                if (backToMenuBtn) backToMenuBtn.onclick = showStart;
            }

            // Spawn functions
            function spawnObstacle() {
                const types = ['small', 'medium', 'large'];
                const type = types[Math.floor(Math.random() * types.length)];
                let w, h;
                if (type === 'small') {
                    w = 30;
                    h = 40;
                } else if (type === 'medium') {
                    w = 50;
                    h = 60;
                } else {
                    w = 70;
                    h = 80;
                }
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                const difficulty = getLevelDifficulty(state.currentLevel);
                state.obstacles.push({
                    x: trackLeft + w / 2 + Math.random() * (state.trackWidth - w),
                    y: -h,
                    w: w,
                    h: h,
                    type: type,
                    vy: state.speed * difficulty.obstacleSpeedMultiplier * (1 + state.levelTime * 0.005)
                });
            }

            function spawnCoin() {
                const sizes = ['small', 'medium', 'large'];
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                let radius;
                if (size === 'small') {
                    radius = 12;
                } else if (size === 'medium') {
                    radius = 18;
                } else {
                    radius = 24;
                }
                state.coinObjects.push({
                    x: 50 + Math.random() * (baseW - 100),
                    y: -radius * 2,
                    radius: radius,
                    size: size,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: 0.1 + Math.random() * 0.1,
                    value: size === 'small' ? 1 : size === 'medium' ? 2 : 3,
                    vy: state.speed * 1.2
                });
            }

            function spawnPowerup() {
                const types = ['shield', 'speed'];
                const type = types[Math.floor(Math.random() * types.length)];
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                state.powerups.push({
                    x: trackLeft + 20 + Math.random() * (state.trackWidth - 40),
                    y: -30,
                    w: 30,
                    h: 30,
                    type: type,
                    rotation: 0,
                    vy: state.speed * 1.1
                });
            }

            function spawnEnemy() {
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                state.enemies.push({
                    x: trackLeft + 30 + Math.random() * (state.trackWidth - 60),
                    y: -40,
                    w: 35,
                    h: 35,
                    prepareTime: 2, // å‡†å¤‡æ—¶é—´2ç§’
                    prepareTimer: 0,
                    hasAimed: false,
                    bulletType: state.currentLevel >= 13 ? 'homing' : 'normal' // 13å…³ä»¥åæ˜¯è·Ÿè¸ªå¯¼å¼¹
                });
            }

            function spawnThunderStrike() {
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                // åœ¨ç©å®¶å‰åå·¦å³ç”Ÿæˆç‚¸å¼¹ï¼Œå‰æ–¹æ¦‚ç‡æ›´é«˜
                const directions = [
                    { x: 0, y: -1, name: 'å‰', weight: 3 },   // å‰é¢ï¼ˆæƒé‡3ï¼Œæ›´å¤šï¼‰
                    { x: 0, y: 1, name: 'å', weight: 1 },    // åé¢ï¼ˆæƒé‡1ï¼‰
                    { x: -1, y: 0, name: 'å·¦', weight: 1 },   // å·¦è¾¹ï¼ˆæƒé‡1ï¼‰
                    { x: 1, y: 0, name: 'å³', weight: 1 }     // å³è¾¹ï¼ˆæƒé‡1ï¼‰
                ];

                // æ ¹æ®æƒé‡éšæœºé€‰æ‹©æ–¹å‘
                const totalWeight = directions.reduce((sum, d) => sum + d.weight, 0);
                let random = Math.random() * totalWeight;
                let dir = directions[0];
                for (let d of directions) {
                    random -= d.weight;
                    if (random <= 0) {
                        dir = d;
                        break;
                    }
                }

                const distance = 60 + Math.random() * 80; // è·ç¦»ç©å®¶60-140åƒç´ 
                let strikeX = state.player.x + dir.x * distance;
                let strikeY = state.player.y + dir.y * distance;

                // ç¡®ä¿Xåœ¨èµ›é“å†…
                const clampedX = clamp(strikeX, trackLeft + 40, trackRight - 40);

                // ç¡®ä¿Yåœ¨å±å¹•èŒƒå›´å†…ï¼ˆåŒ…æ‹¬æœ€å‰é¢ï¼‰
                const minY = state.player.h / 2;
                const maxY = baseH - state.player.h / 2;
                strikeY = clamp(strikeY, minY, maxY);

                state.thunderStrikes.push({
                    x: clampedX,
                    y: strikeY, // ç›®æ ‡Yä½ç½®ï¼ˆåœ°é¢ä½ç½®ï¼‰
                    startY: 0,
                    radius: 50, // çº¢è‰²åœ†åœˆåŠå¾„
                    prepareTime: 0, // æ— å‡†å¤‡æ—¶é—´ï¼Œä½†ä¼šæ˜¾ç¤ºçº¢åœˆ
                    prepareTimer: 0,
                    hasStruck: false,
                    hasHitPlayer: false, // æ ‡è®°æ˜¯å¦å·²å‡»ä¸­ç©å®¶
                    damage: 20, // ä¼¤å®³20è¡€
                    fallSpeed: 8, // æ‰è½é€Ÿåº¦
                    currentY: 0, // ä»å¤©ä¸Šå¼€å§‹æ‰è½
                    hasStartedFalling: true // ç«‹åˆ»å¼€å§‹æ‰è½
                });
            }

            function spawnMultipleThunderStrikes(count) {
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                const minY = state.player.h / 2;
                const maxY = baseH - state.player.h / 2;

                // å®šä¹‰æ‰€æœ‰å¯èƒ½çš„ä½ç½®ï¼ˆå‰åå·¦å³ï¼Œä»¥åŠç»„åˆä½ç½®ï¼‰
                const allPositions = [
                    { x: 0, y: -1, name: 'å‰' },   // å‰é¢
                    { x: 0, y: 1, name: 'å' },    // åé¢
                    { x: -1, y: 0, name: 'å·¦' },   // å·¦è¾¹
                    { x: 1, y: 0, name: 'å³' },    // å³è¾¹
                    { x: -0.7, y: -0.7, name: 'å‰å·¦' }, // å‰å·¦
                    { x: 0.7, y: -0.7, name: 'å‰å³' },  // å‰å³
                    { x: -0.7, y: 0.7, name: 'åå·¦' },  // åå·¦
                    { x: 0.7, y: 0.7, name: 'åå³' }    // åå³
                ];

                // æ ¹æ®æ•°é‡é€‰æ‹©ä½ç½®ç­–ç•¥ï¼Œç¡®ä¿åˆ†æ•£åœ¨ä¸åŒæ–¹å‘ï¼Œä¸æŒ¨åœ¨ä¸€èµ·
                const minDistance = 120; // ç‚¸å¼¹ä¹‹é—´çš„æœ€å°è·ç¦»ï¼ˆä¸æŒ¨åœ¨ä¸€èµ·ï¼‰
                let selectedPositions = [];
                const actualCount = Math.min(count, 4);

                // å®šä¹‰ä¸»è¦æ–¹å‘
                const mainDirections = [
                    { x: 0, y: -1, name: 'ä¸Š' },   // ä¸Šé¢
                    { x: 0, y: 1, name: 'ä¸‹' },    // ä¸‹é¢
                    { x: -1, y: 0, name: 'å·¦' },   // å·¦è¾¹
                    { x: 1, y: 0, name: 'å³' },    // å³è¾¹
                    { x: 0, y: 0, name: 'ä¸­' }     // ä¸­é—´ï¼ˆç©å®¶ä½ç½®é™„è¿‘ï¼‰
                ];

                if (actualCount === 1) {
                    // 1ä¸ªç‚¸å¼¹ï¼šéšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘
                    const dir = mainDirections[Math.floor(Math.random() * 4)]; // åªé€‰ä¸Šä¸‹å·¦å³
                    selectedPositions.push(dir);
                } else if (actualCount === 2) {
                    // 2ä¸ªç‚¸å¼¹ï¼šé€‰æ‹©ä¸¤ä¸ªä¸åŒçš„ä¸»è¦æ–¹å‘ï¼ˆç¡®ä¿ä¸æŒ¨åœ¨ä¸€èµ·ï¼‰
                    const shuffled = [...mainDirections.slice(0, 4)].sort(() => Math.random() - 0.5);
                    selectedPositions = shuffled.slice(0, 2);
                } else if (actualCount === 3) {
                    // 3ä¸ªç‚¸å¼¹ï¼šç¡®ä¿è¦†ç›–ä¸åŒåŒºåŸŸï¼ˆæ¯”å¦‚ï¼šä¸Šã€å·¦ã€å³ æˆ– ä¸‹ã€å·¦ã€å³ï¼‰
                    const directions = [...mainDirections.slice(0, 4)].sort(() => Math.random() - 0.5);
                    selectedPositions = directions.slice(0, 3);
                } else if (actualCount === 4) {
                    // 4ä¸ªç‚¸å¼¹ï¼šä¸­é—´ã€å·¦è¾¹ã€å³è¾¹ã€ä¸Šé¢ï¼ˆç¡®ä¿å“ªé‡Œéƒ½èµ°ä¸å¼€ï¼‰
                    selectedPositions = [
                        { x: 0, y: 0, name: 'ä¸­' },   // ä¸­é—´
                        { x: -1, y: 0, name: 'å·¦' },  // å·¦è¾¹
                        { x: 1, y: 0, name: 'å³' },   // å³è¾¹
                        { x: 0, y: -1, name: 'ä¸Š' }   // ä¸Šé¢
                    ];
                }

                // ç”Ÿæˆç‚¸å¼¹ï¼Œç¡®ä¿ä¸æŒ¨åœ¨ä¸€èµ·
                const generatedBombs = [];
                for (let pos of selectedPositions) {
                    let attempts = 0;
                    let validPosition = false;
                    let strikeX, strikeY;

                    // å°è¯•æ‰¾åˆ°ä¸€ä¸ªä¸ä¸å…¶ä»–ç‚¸å¼¹å¤ªè¿‘çš„ä½ç½®
                    while (!validPosition && attempts < 10) {
                        const distance = 70 + Math.random() * 90; // è·ç¦»ç©å®¶70-160åƒç´ 
                        strikeX = state.player.x + pos.x * distance;
                        strikeY = state.player.y + pos.y * distance;

                        // ç¡®ä¿Xåœ¨èµ›é“å†…
                        strikeX = clamp(strikeX, trackLeft + 40, trackRight - 40);

                        // ç¡®ä¿Yåœ¨å±å¹•èŒƒå›´å†…
                        strikeY = clamp(strikeY, minY, maxY);

                        // æ£€æŸ¥æ˜¯å¦ä¸å·²ç”Ÿæˆçš„ç‚¸å¼¹å¤ªè¿‘
                        validPosition = true;
                        for (let bomb of generatedBombs) {
                            const dx = strikeX - bomb.x;
                            const dy = strikeY - bomb.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }

                        attempts++;
                    }

                    // å¦‚æœæ‰¾åˆ°äº†æœ‰æ•ˆä½ç½®ï¼Œç”Ÿæˆç‚¸å¼¹
                    if (validPosition) {
                        generatedBombs.push({ x: strikeX, y: strikeY });
                        state.thunderStrikes.push({
                            x: strikeX,
                            y: strikeY, // ç›®æ ‡Yä½ç½®ï¼ˆåœ°é¢ä½ç½®ï¼‰
                            startY: 0,
                            radius: 50, // çº¢è‰²åœ†åœˆåŠå¾„
                            prepareTime: 0, // æ— å‡†å¤‡æ—¶é—´ï¼Œä½†ä¼šæ˜¾ç¤ºçº¢åœˆ
                            prepareTimer: 0,
                            hasStruck: false,
                            hasHitPlayer: false, // æ ‡è®°æ˜¯å¦å·²å‡»ä¸­ç©å®¶
                            damage: 20, // ä¼¤å®³20è¡€
                            fallSpeed: 8, // æ‰è½é€Ÿåº¦
                            currentY: 0, // ä»å¤©ä¸Šå¼€å§‹æ‰è½
                            hasStartedFalling: true // ç«‹åˆ»å¼€å§‹æ‰è½
                        });
                    }
                }
            }

            // Drawing functions
            function drawBackground() {
                // èƒŒæ™¯
                const grad = ctx.createLinearGradient(0, 0, 0, baseH);
                grad.addColorStop(0, '#87CEEB');
                grad.addColorStop(0.5, '#98D8C8');
                grad.addColorStop(1, '#6B8E23');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, baseW, baseH);

                // èµ›é“
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                ctx.fillStyle = '#555555';
                ctx.fillRect(trackLeft, 0, state.trackWidth, baseH);

                // èµ›é“è¾¹ç¼˜çº¿
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(trackLeft, 0);
                ctx.lineTo(trackLeft, baseH);
                ctx.moveTo(trackRight, 0);
                ctx.lineTo(trackRight, baseH);
                ctx.stroke();

                // å›´æ 
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                const fenceSpacing = 30;
                for (let y = 0; y < baseH; y += fenceSpacing) {
                    // å·¦ä¾§å›´æ 
                    ctx.beginPath();
                    ctx.moveTo(trackLeft - 20, y);
                    ctx.lineTo(trackLeft - 20, y + 15);
                    ctx.stroke();
                    // å³ä¾§å›´æ 
                    ctx.beginPath();
                    ctx.moveTo(trackRight + 20, y);
                    ctx.lineTo(trackRight + 20, y + 15);
                    ctx.stroke();
                }

                // èµ›é“ä¸­å¿ƒçº¿
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([20, 20]);
                ctx.lineDashOffset = state.tick * 2;
                ctx.beginPath();
                ctx.moveTo(state.trackX, 0);
                ctx.lineTo(state.trackX, baseH);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            function drawPlayer(p) {
                ctx.save();
                ctx.translate(p.x, p.y);

                // æŠ¤ç›¾æ•ˆæœ
                if (state.hasShield) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.w / 2 + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // æ›´æ–°å¥”è·‘åŠ¨ç”»å¸§
                if (state.playing && !state.paused) {
                    p.runFrame += 0.3;
                    if (p.runFrame >= 8) p.runFrame = 0;
                }

                // èº«ä½“
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(-p.w / 2, -p.h / 2 + 5, p.w, p.h - 10);

                // å¤´éƒ¨
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(0, -p.h / 2 - 10, 12, 0, Math.PI * 2);
                ctx.fill();

                // çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-4, -p.h / 2 - 10, 2, 0, Math.PI * 2);
                ctx.arc(4, -p.h / 2 - 10, 2, 0, Math.PI * 2);
                ctx.fill();

                // å˜´å·´
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -p.h / 2 - 6, 3, 0, Math.PI);
                ctx.stroke();

                // æ‰‹è‡‚ï¼ˆè·‘æ­¥åŠ¨ç”» - æ›´æ˜æ˜¾çš„æ‘†åŠ¨ï¼‰
                const frame = Math.floor(p.runFrame);
                const armPhase = (frame % 4) / 4 * Math.PI * 2;
                const leftArmAngle = Math.sin(armPhase) * 0.6;
                const rightArmAngle = Math.sin(armPhase + Math.PI) * 0.6;

                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(-p.w / 2, -p.h / 2 + 15);
                ctx.lineTo(-p.w / 2 - 12, -p.h / 2 + 15 + Math.sin(leftArmAngle) * 12);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(p.w / 2, -p.h / 2 + 15);
                ctx.lineTo(p.w / 2 + 12, -p.h / 2 + 15 + Math.sin(rightArmAngle) * 12);
                ctx.stroke();

                // è…¿éƒ¨ï¼ˆè·‘æ­¥åŠ¨ç”» - æ›´æ˜æ˜¾çš„äº¤æ›¿ï¼‰
                const leftLegAngle = Math.sin(armPhase) * 0.4;
                const rightLegAngle = Math.sin(armPhase + Math.PI) * 0.4;

                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(-p.w / 4, p.h / 2 - 5);
                ctx.lineTo(-p.w / 4 - 3, p.h / 2 + 18 + Math.sin(leftLegAngle) * 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(p.w / 4, p.h / 2 - 5);
                ctx.lineTo(p.w / 4 + 3, p.h / 2 + 18 + Math.sin(rightLegAngle) * 8);
                ctx.stroke();

                // è„š
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(-p.w / 4 - 3, p.h / 2 + 18 + Math.sin(leftLegAngle) * 8, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(p.w / 4 + 3, p.h / 2 + 18 + Math.sin(rightLegAngle) * 8, 6, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawObstacle(o) {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(o.x - o.w / 2, o.y - o.h / 2, o.w, o.h);
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(o.x - o.w / 2, o.y - o.h / 2, o.w, o.h);
            }

            function drawCoin(c) {
                ctx.save();
                ctx.translate(c.x, c.y);
                c.rotation += c.rotationSpeed;

                // å‘å…‰æ•ˆæœ
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, c.radius * 1.5);
                glow.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
                glow.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
                glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(0, 0, c.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // é‡‘å¸ä¸»ä½“
                ctx.rotate(c.rotation);
                ctx.fillStyle = '#ffd700';
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, c.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // é‡‘å¸ç¬¦å·
                ctx.fillStyle = '#ffaa00';
                ctx.font = `bold ${c.radius * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', 0, 0);

                ctx.restore();
            }

            function drawPowerup(p) {
                ctx.save();
                ctx.translate(p.x, p.y);
                p.rotation += 0.1;

                // å‘å…‰æ•ˆæœ
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, p.w);
                if (p.type === 'shield') {
                    glow.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
                    glow.addColorStop(1, 'rgba(0, 255, 0, 0)');
                } else {
                    glow.addColorStop(0, 'rgba(255, 107, 107, 0.6)');
                    glow.addColorStop(1, 'rgba(255, 107, 107, 0)');
                }
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(0, 0, p.w, 0, Math.PI * 2);
                ctx.fill();

                ctx.rotate(p.rotation);
                if (p.type === 'shield') {
                    ctx.fillStyle = '#00ff00';
                    ctx.strokeStyle = '#00aa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.w / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ›¡ï¸', 0, 0);
                } else {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.w / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('âš¡', 0, 0);
                }

                ctx.restore();
            }

            function drawThunderStrike(ts) {
                ctx.save();
                const targetY = ts.y; // ä½¿ç”¨ç‚¸å¼¹çš„ç›®æ ‡Yä½ç½®ï¼ˆåœ°é¢ä½ç½®ï¼‰

                // åœ¨åœ°é¢æ˜¾ç¤ºçº¢è‰²åœ†åœˆæ ‡è®°ï¼ˆè­¦å‘Šç©å®¶ï¼‰
                if (!ts.hasStruck) {
                    // è®¡ç®—æ‰è½è¿›åº¦ï¼ˆç”¨äºçº¢åœˆé—ªçƒæ•ˆæœï¼‰
                    const fallProgress = Math.min(1, ts.currentY / targetY);
                    const alpha = 0.4 + fallProgress * 0.4;
                    const radius = ts.radius * (0.9 + fallProgress * 0.1);

                    // å¤–åœˆï¼ˆé—ªçƒæ•ˆæœï¼‰
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 4 + fallProgress * 2;
                    ctx.beginPath();
                    ctx.arc(ts.x, targetY, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // å†…åœˆå¡«å……
                    ctx.fillStyle = `rgba(255, 0, 0, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(ts.x, targetY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // æ˜¾ç¤ºç‚¸å¼¹å’Œè½¨è¿¹ï¼ˆä»å¤©ä¸Šæ‰ä¸‹æ¥ï¼‰
                if (!ts.hasStruck) {
                    // ç‚¸å¼¹æ‰è½è½¨è¿¹
                    if (ts.currentY < targetY && ts.currentY >= 0) {
                        ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(ts.x, 0);
                        ctx.lineTo(ts.x, ts.currentY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // ç»˜åˆ¶ç‚¸å¼¹ï¼ˆä»å¤©ä¸Šæ‰ä¸‹æ¥ï¼‰
                    if (ts.currentY < targetY && ts.currentY >= 0) {
                        ctx.save();
                        ctx.translate(ts.x, ts.currentY);

                        // ç‚¸å¼¹ä¸»ä½“
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.fill();

                        // ç‚¸å¼¹å¼•çº¿
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -12);
                        ctx.lineTo(0, -20);
                        ctx.stroke();

                        // ç‚¸å¼¹ç«èŠ±
                        const time = performance.now() / 100;
                        const sparkAngle = (time * 0.3) % (Math.PI * 2);
                        ctx.strokeStyle = '#ffaa00';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 4; i++) {
                            const angle = sparkAngle + (i * Math.PI / 2);
                            ctx.beginPath();
                            ctx.moveTo(0, -20);
                            ctx.lineTo(Math.cos(angle) * 8, -20 + Math.sin(angle) * 8);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }
                }

                // çˆ†ç‚¸æ•ˆæœï¼ˆå¦‚æœå·²ç»å‡»ä¸­ï¼‰
                if (ts.hasStruck) {
                    // çˆ†ç‚¸åœ†åœˆ
                    const explosionTime = ts.prepareTimer;
                    const explosionSize = 40 + explosionTime * 20;
                    const explosionAlpha = Math.max(0, 1 - explosionTime * 2);

                    // å¤–å±‚çˆ†ç‚¸
                    ctx.fillStyle = `rgba(255, 200, 0, ${explosionAlpha})`;
                    ctx.beginPath();
                    ctx.arc(ts.x, targetY, explosionSize, 0, Math.PI * 2);
                    ctx.fill();

                    // å†…å±‚çˆ†ç‚¸
                    ctx.fillStyle = `rgba(255, 100, 0, ${explosionAlpha})`;
                    ctx.beginPath();
                    ctx.arc(ts.x, targetY, explosionSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // ä¸­å¿ƒçˆ†ç‚¸
                    ctx.fillStyle = `rgba(255, 255, 255, ${explosionAlpha})`;
                    ctx.beginPath();
                    ctx.arc(ts.x, targetY, explosionSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            // Update loop
            let last = performance.now();
            function loop(now) {
                requestAnimationFrame(loop);
                const dt = Math.min(33, now - last) / 16.6667;
                last = now;

                // UI updates
                document.getElementById('level').textContent = state.currentLevel;
                document.getElementById('time').textContent = Math.floor(state.levelTime);
                document.getElementById('coins').textContent = state.coins;
                document.getElementById('hp').textContent = Math.max(0, Math.floor(state.hp));
                document.getElementById('maxHp').textContent = state.maxHp;
                // è¡€é‡é¢œè‰²å˜åŒ–
                const hpEl = document.getElementById('hp');
                if (state.hp <= 30) {
                    hpEl.style.color = '#ff6b6b';
                } else if (state.hp <= 50) {
                    hpEl.style.color = '#ffd700';
                } else {
                    hpEl.style.color = '#e6f0ff';
                }

                // æŠ¤ç›¾å’ŒåŠ é€ŸæŒ‡ç¤ºå™¨
                const shieldIndicator = document.getElementById('shieldIndicator');
                const speedIndicator = document.getElementById('speedIndicator');
                if (state.hasShield) {
                    shieldIndicator.style.display = 'flex';
                    shieldIndicator.classList.add('shield-active');
                } else {
                    shieldIndicator.style.display = 'none';
                    shieldIndicator.classList.remove('shield-active');
                }
                if (state.speedBoost) {
                    speedIndicator.style.display = 'flex';
                    speedIndicator.classList.add('speed-active');
                } else {
                    speedIndicator.style.display = 'none';
                    speedIndicator.classList.remove('speed-active');
                }

                drawBackground();

                if (!state.playing || state.paused) {
                    drawPlayer(state.player);
                    state.obstacles.forEach(drawObstacle);
                    state.coinObjects.forEach(drawCoin);
                    state.powerups.forEach(drawPowerup);
                    state.enemies.forEach(drawEnemy);
                    state.bullets.forEach(drawBullet);
                    state.thunderStrikes.forEach(drawThunderStrike);
                    return;
                }

                state.tick++;
                state.gameTime += dt / 60; // è½¬æ¢ä¸ºç§’
                state.levelTime += dt / 60; // å…³å¡æ—¶é—´

                // é‡‘å¸ç³»ç»Ÿï¼šæ¯ç§’0.1é‡‘å¸ï¼Œæ¯10ç§’æ˜¾ç¤º1ä¸ª
                state.coinCounter += 0.1 * (dt / 60);
                if (state.coinCounter >= 1) {
                    state.coins += Math.floor(state.coinCounter);
                    state.coinCounter = state.coinCounter % 1;
                }


                // é“å…·æŒç»­æ—¶é—´
                if (state.hasShield) {
                    state.shieldTime -= dt / 60;
                    if (state.shieldTime <= 0) {
                        state.hasShield = false;
                    }
                }
                if (state.speedBoost) {
                    state.speedBoostTime -= dt / 60;
                    if (state.speedBoostTime <= 0) {
                        state.speedBoost = false;
                        state.speed = state.baseSpeed;
                    }
                }

                // ç”Ÿæˆéšœç¢ç‰©ï¼ˆæ ¹æ®å…³å¡éš¾åº¦ï¼Œå¤§é‡ç”Ÿæˆï¼‰
                const difficulty = getLevelDifficulty(state.currentLevel);
                if (state.tick % difficulty.obstacleSpawnRate === 0) {
                    spawnObstacle();
                }
                if (state.tick % (difficulty.obstacleSpawnRate / 2) === 0 && Math.random() < difficulty.obstacleSpawnChance) {
                    spawnObstacle();
                }
                // é¢å¤–ç”Ÿæˆéšœç¢ç‰©ï¼ˆæ‰€æœ‰å…³å¡éƒ½æœ‰ï¼‰
                if (state.tick % (difficulty.obstacleSpawnRate / 3) === 0 && Math.random() < difficulty.obstacleSpawnChance * 0.6) {
                    spawnObstacle();
                }
                // æ›´å¤šé¢å¤–ç”Ÿæˆï¼ˆå¢åŠ éš¾åº¦ï¼‰
                if (state.tick % (difficulty.obstacleSpawnRate / 4) === 0 && Math.random() < difficulty.obstacleSpawnChance * 0.4) {
                    spawnObstacle();
                }

                // æ ¹æ®å‡çº§åçš„é—´éš”æ‰è½é‡‘å¸ï¼ˆåœ¨ç©å®¶é™„è¿‘çš„èµ›é“å†…ï¼‰
                if (state.gameTime - state.lastCoinDropTime >= state.coinSpawnInterval) {
                    const trackLeft = state.trackX - state.trackWidth / 2;
                    const trackRight = state.trackX + state.trackWidth / 2;
                    const dropX = state.player.x + (Math.random() - 0.5) * 150;
                    const clampedX = clamp(dropX, trackLeft + 30, trackRight - 30);
                    const sizes = ['small', 'medium', 'large'];
                    const size = sizes[Math.floor(Math.random() * sizes.length)];
                    let radius;
                    if (size === 'small') {
                        radius = 12;
                    } else if (size === 'medium') {
                        radius = 18;
                    } else {
                        radius = 24;
                    }
                    state.coinObjects.push({
                        x: clampedX,
                        y: -radius * 2,
                        radius: radius,
                        size: size,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: 0.1 + Math.random() * 0.1,
                        value: size === 'small' ? 1 : size === 'medium' ? 2 : 3,
                        vy: state.speed * 1.2
                    });
                    state.lastCoinDropTime = state.gameTime;
                }

                // ç”Ÿæˆé“å…·
                if (state.tick % 300 === 0) {
                    spawnPowerup();
                }

                // ç”Ÿæˆé›·å‡»ï¼ˆæ¯å…³éƒ½ä¼šæœ‰ï¼Œæ¯1ç§’ç”Ÿæˆ2-4ä¸ªï¼Œå¢åŠ éš¾åº¦ï¼‰
                if (state.tick % 60 === 0) {
                    // å¿«é€Ÿéšæœºè½¬ç›˜å†³å®šç”Ÿæˆ2-4ä¸ªç‚¸å¼¹ï¼ˆéšè—è¿›è¡Œï¼Œé€Ÿåº¦å¾ˆå¿«ï¼‰
                    // ä½¿ç”¨å¤šä¸ªéšæœºæ•°æ¨¡æ‹Ÿè½¬ç›˜ï¼Œç¡®ä¿éšæœºæ€§
                    const random1 = Math.random();
                    const random2 = Math.random();
                    const random3 = Math.random();
                    // ç»¼åˆå¤šä¸ªéšæœºæ•°ï¼Œç”Ÿæˆ2-4ä¹‹é—´çš„éšæœºæ•°ï¼ˆæé«˜éš¾åº¦ï¼‰
                    // æ¦‚ç‡åˆ†å¸ƒï¼š2ä¸ª(20%), 3ä¸ª(40%), 4ä¸ª(40%) - å¢åŠ éš¾åº¦
                    const totalRandom = (random1 + random2 + random3) / 3;
                    let bombCount;
                    if (totalRandom < 0.20) {
                        bombCount = 2; // 20%æ¦‚ç‡
                    } else if (totalRandom < 0.60) {
                        bombCount = 3; // 40%æ¦‚ç‡
                    } else {
                        bombCount = 4; // 40%æ¦‚ç‡
                    }

                    // ç”ŸæˆæŒ‡å®šæ•°é‡çš„ç‚¸å¼¹ï¼Œç¡®ä¿ä½ç½®ä¸é‡å¤
                    spawnMultipleThunderStrikes(bombCount);
                }

                // ç©å®¶ç‰©ç†
                const acc = 0.5;
                const fric = 0.85;
                const trackLeft = state.trackX - state.trackWidth / 2;
                const trackRight = state.trackX + state.trackWidth / 2;
                // å…¨å±ç§»åŠ¨èŒƒå›´
                const minY = state.player.h / 2; // ç©å®¶å¯ä»¥ç§»åŠ¨çš„æœ€å°Yä½ç½®ï¼ˆå±å¹•é¡¶éƒ¨ï¼‰
                const maxY = baseH - state.player.h / 2; // ç©å®¶å¯ä»¥ç§»åŠ¨çš„æœ€å¤§Yä½ç½®ï¼ˆå±å¹•åº•éƒ¨ï¼‰

                // å·¦å³ç§»åŠ¨
                if (keys.left) state.player.vx -= acc;
                if (keys.right) state.player.vx += acc;
                state.player.vx = clamp(state.player.vx, -state.player.maxV, state.player.maxV);
                state.player.x += state.player.vx * dt;
                state.player.vx *= fric;
                // é™åˆ¶åœ¨èµ›é“å†…
                state.player.x = clamp(state.player.x, trackLeft + state.player.w / 2, trackRight - state.player.w / 2);

                // å‰åç§»åŠ¨ï¼ˆå…¨å±ï¼‰
                if (keys.up) state.player.vy -= acc;
                if (keys.down) state.player.vy += acc;
                state.player.vy = clamp(state.player.vy, -state.player.maxVy, state.player.maxVy);
                state.player.y += state.player.vy * dt;
                state.player.vy *= fric;
                // é™åˆ¶åœ¨å…¨å±èŒƒå›´å†…
                state.player.y = clamp(state.player.y, minY, maxY);

                // è¸æ­¥éŸ³æ•ˆï¼ˆç§»åŠ¨æ—¶æ’­æ”¾ï¼‰
                if (state.playing && !state.paused && (keys.left || keys.right || keys.up || keys.down || Math.abs(state.player.vx) > 0.1 || Math.abs(state.player.vy) > 0.1)) {
                    const frame = Math.floor(state.player.runFrame);
                    if (frame !== Math.floor(state.player.lastStepTime)) {
                        if (frame % 4 === 0 || frame % 4 === 2) {
                            try {
                                playStepSound();
                            } catch (e) {
                                // å¿½ç•¥éŸ³æ•ˆé”™è¯¯
                            }
                        }
                        state.player.lastStepTime = frame;
                    }
                }

                // æ›´æ–°éšœç¢ç‰©
                for (let i = state.obstacles.length - 1; i >= 0; i--) {
                    const o = state.obstacles[i];
                    o.y += o.vy * dt;
                    drawObstacle(o);

                    // ç¢°æ’æ£€æµ‹
                    if (aabb(state.player, o)) {
                        if (state.hasShield) {
                            // æŠ¤ç›¾æŠµæŒ¡ä¸€æ¬¡ä¼¤å®³
                            state.hasShield = false;
                            state.shieldTime = 0;
                            state.obstacles.splice(i, 1);
                            continue;
                        } else {
                            // æ‰£è¡€ï¼ˆä½¿ç”¨damagePerHitï¼‰
                            state.hp -= state.damagePerHit;
                            state.obstacles.splice(i, 1);
                            // å¦‚æœè¡€é‡<=0ï¼Œæ¸¸æˆç»“æŸ
                            if (state.hp <= 0) {
                                endGame();
                                return;
                            }
                            continue;
                        }
                    }

                    if (o.y > baseH + 100) {
                        state.obstacles.splice(i, 1);
                    }
                }

                // æ›´æ–°é‡‘å¸
                for (let i = state.coinObjects.length - 1; i >= 0; i--) {
                    const c = state.coinObjects[i];
                    c.y += c.vy * dt;
                    drawCoin(c);

                    // æ”¶é›†æ£€æµ‹
                    const dx = state.player.x - c.x;
                    const dy = state.player.y - c.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < state.player.w / 2 + c.radius) {
                        // æ”¶é›†é‡‘å¸ç«‹å³å¢åŠ 
                        state.coins += c.value;
                        state.coinObjects.splice(i, 1);
                        continue;
                    }

                    if (c.y > baseH + 100) {
                        state.coinObjects.splice(i, 1);
                    }
                }

                // æ›´æ–°é“å…·
                for (let i = state.powerups.length - 1; i >= 0; i--) {
                    const p = state.powerups[i];
                    p.y += p.vy * dt;
                    drawPowerup(p);

                    // æ”¶é›†æ£€æµ‹
                    if (aabb(state.player, p)) {
                        // å¦‚æœå·²ç»æœ‰æ¿€æ´»çš„é“å…·ï¼Œå–æ¶ˆå®ƒ
                        if (state.activePowerup) {
                            if (state.activePowerup.type === 'shield') {
                                state.hasShield = false;
                                state.shieldTime = 0;
                            } else if (state.activePowerup.type === 'speed') {
                                state.speedBoost = false;
                                state.speedBoostTime = 0;
                                state.speed = state.baseSpeed;
                            }
                        }

                        // æ¿€æ´»æ–°é“å…·
                        if (p.type === 'shield') {
                            state.hasShield = true;
                            state.shieldTime = 10; // 10ç§’æŠ¤ç›¾
                            state.activePowerup = { type: 'shield', endTime: state.gameTime + 10 };
                        } else if (p.type === 'speed') {
                            state.speedBoost = true;
                            state.speedBoostTime = 8; // 8ç§’åŠ é€Ÿ
                            state.speed = state.baseSpeed * 1.5;
                            state.activePowerup = { type: 'speed', endTime: state.gameTime + 8 };
                        }
                        state.powerups.splice(i, 1);
                        continue;
                    }

                    if (p.y > baseH + 100) {
                        state.powerups.splice(i, 1);
                    }
                }

                // æ£€æŸ¥é“å…·æ˜¯å¦è¿‡æœŸ
                if (state.activePowerup && state.gameTime >= state.activePowerup.endTime) {
                    if (state.activePowerup.type === 'shield') {
                        state.hasShield = false;
                        state.shieldTime = 0;
                    } else if (state.activePowerup.type === 'speed') {
                        state.speedBoost = false;
                        state.speedBoostTime = 0;
                        state.speed = state.baseSpeed;
                    }
                    state.activePowerup = null;
                }

                // æ›´æ–°é›·å‡»ï¼ˆç‚¸å¼¹ï¼‰
                for (let i = state.thunderStrikes.length - 1; i >= 0; i--) {
                    const ts = state.thunderStrikes[i];
                    const targetY = ts.y; // ä½¿ç”¨ç‚¸å¼¹çš„ç›®æ ‡Yä½ç½®

                    // ç‚¸å¼¹æ‰è½åŠ¨ç”»ï¼ˆæ— å‡†å¤‡æ—¶é—´ï¼Œç«‹åˆ»æ‰è½ï¼‰
                    if (ts.currentY < targetY) {
                        ts.currentY += ts.fallSpeed * dt;
                        if (ts.currentY > targetY) {
                            ts.currentY = targetY;
                        }
                    }

                    drawThunderStrike(ts);

                    // ç‚¸å¼¹æ‰è½åˆ°ç›®æ ‡ä½ç½®åï¼Œæ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨çº¢è‰²åŒºåŸŸ
                    if (ts.currentY >= targetY && !ts.hasStruck) {
                        ts.hasStruck = true;
                        ts.prepareTimer = 0; // é‡ç½®è®¡æ—¶å™¨ç”¨äºçˆ†ç‚¸åŠ¨ç”»
                    }

                    // å¦‚æœç‚¸å¼¹å·²ç»çˆ†ç‚¸ï¼ŒæŒç»­æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨çˆ†ç‚¸èŒƒå›´å†…ï¼ˆç¡®ä¿æŒç»­æ£€æµ‹ï¼‰
                    if (ts.hasStruck && ts.prepareTimer < 0.1) {
                        // è®¡ç®—ç©å®¶å’Œç‚¸å¼¹çˆ†ç‚¸ç‚¹çš„è·ç¦»
                        const dx = state.player.x - ts.x;
                        const dy = state.player.y - targetY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // å¦‚æœç©å®¶åœ¨çˆ†ç‚¸èŒƒå›´å†…ï¼Œå—åˆ°ä¼¤å®³ï¼ˆåªæ£€æµ‹ä¸€æ¬¡ï¼‰
                        if (dist < ts.radius && !ts.hasHitPlayer) {
                            ts.hasHitPlayer = true; // æ ‡è®°å·²å‡»ä¸­ç©å®¶ï¼Œé¿å…é‡å¤ä¼¤å®³

                            // åªæœ‰å‡»ä¸­ç©å®¶æ—¶æ‰æ’­æ”¾éŸ³æ•ˆ
                            playExplosionSound();

                            if (state.hasShield) {
                                // æŠ¤ç›¾å¯ä»¥æŠµæŒ¡ä¸€æ¬¡é›·å‡»
                                state.hasShield = false;
                                state.shieldTime = 0;
                                if (state.activePowerup && state.activePowerup.type === 'shield') {
                                    state.activePowerup = null;
                                }
                            } else {
                                // å—åˆ°20ç‚¹ä¼¤å®³
                                state.hp -= 20; // ç‚¸å¼¹ä¼¤å®³20è¡€
                                if (state.hp <= 0) {
                                    endGame();
                                    return;
                                }
                            }
                        }
                    }

                    // çˆ†ç‚¸æ•ˆæœæŒç»­0.3ç§’åç§»é™¤
                    if (ts.hasStruck) {
                        ts.prepareTimer += dt / 60;
                        if (ts.prepareTimer >= 0.3) {
                            state.thunderStrikes.splice(i, 1);
                        }
                    }
                }

                // å…³å¡å®Œæˆæ£€æµ‹
                if (state.levelTime >= state.levelTargetTime) {
                    completeLevel();
                    return;
                }

                // ç»˜åˆ¶ç©å®¶
                drawPlayer(state.player);

                // ç»˜åˆ¶æ•Œäººã€å­å¼¹å’Œé›·å‡»ï¼ˆé›·å‡»åœ¨æ›´æ–°å¾ªç¯ä¸­å·²ç»ç»˜åˆ¶ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤ï¼‰
            }
            requestAnimationFrame(loop);

            showStart();
        })();
    </script>
</body>

</htmæ¸¸æˆæ€ä¹ˆæ²¡æ‰“å¼€å‘€ï¼Ÿæ€ä¹ˆæ‰“å¼€æ¸¸æˆå•Šï¼Ÿæ‰“å¼€æ¸¸æˆã€‚çˆ¸çˆ¸çˆ¸çˆ¸çˆ¸çˆ¸æ€ä¹ˆæ‰“å¼€æ¸¸æˆï¼Ÿ